% DEMO_SIFT_AND_POOLING
%
%   This experiment compares pooling techniques within the context of
%   a binary classification problem.  In this problem objects of class
%   A are images consisting predominantly of gaussian noise except for
%   a small region where there is some deterministic oscillation.
%   Objects of class B are purely gaussian noise.
%
%   The hope was to observe that maxfun pooling provides some
%   quantitative advantage in this setting. This experiment turned out
%   to be uninformative in that, while there was a clear difference in
%   the performance of pooling techniques on the raw input images, the
%   simple process of running SIFT on these images generated features
%   that rendered these two classes trivially separable.  This
%   suggests that more care needs to be placed in setting up the
%   classification problem of interest.
%
%   One thought is that if maxfun is well suited to identifying
%   oscillatory signals, we would like a signal representation that
%   manifests these features.  Oscillations in the input space is
%   seemingly well-addressed by SIFT.
%

% mjp, may 2016


%% Experiment Parameters
sz = [250 250];        % image size
szTag = 30;            % oscillatory tag size
sigma = 2;             % standard deviation of Gaussian noise
nExamples = 100;       % total # of examples to create *per class*
nFolds = 5;            % number of folds to split dataset into

% SIFT parameters: generate descriptors every 4 pixels with no
% macrofeatures.  Implicitly we are using the default SIFT
% descriptor sizes (4 x 4 x 8 = 128 SIFT dimensions).
run_sift = @(I) sift_macrofeatures(single(I), 'subsamp', 1, 'step', 4, 'macrosl', 1);



%% Create synthetic data
data.Xraw = zeros(sz(1), sz(2), 2*nExamples);
data.y = zeros(2*nExamples,1);

fprintf('[%s]: generating synthetic data\n', mfilename);
for ii = 1:nExamples
    % Create two random images
    A = sigma * randn(sz);
    B = sigma * randn(sz);

    % Apply a small oscillatory "tag" within the interior of image A
    Tag = max(A(:))*real(make_plane_wave(10,10,szTag));
    x0 = ceil(rand()*(sz(2)-szTag-10));
    y0 = ceil(rand()*(sz(1)-szTag-10));
    A(x0:x0+szTag-1, y0:y0+szTag-1) = Tag;

    idx = (ii-1)*2 + 1;
    data.Xraw(:,:,idx) = A;
    data.Xraw(:,:,idx+1) = B;
    data.y(idx) = 0;
    data.y(idx) = 1;
end

data.foldId = assign_folds(data.y, nFolds);


%% An intermediate analysis

% Here we quickly look at the impact of different pooling functions
% on the raw data.  Of course in an actual application we do not
% attempt to summarize an entire image using a single scalar
% generated by pooling; this is just to see whether indeed the
% maxfun seems better suited to oscillatory data in a general
% sense.


fprintf('[%s]: pooling raw data - please wait a few moments...\n', mfilename);

P = zeros(nExamples, 6);
P(:,1) = spatial_pool(data.Xraw(:,:,data.y==0), 'avg');
P(:,2) = spatial_pool(data.Xraw(:,:,data.y==1), 'avg');
P(:,3) = spatial_pool(data.Xraw(:,:,data.y==0), 'max');
P(:,4) = spatial_pool(data.Xraw(:,:,data.y==1), 'max');
P(:,5) = spatial_pool(data.Xraw(:,:,data.y==0), 'fun', 10);  % choose 10 arbitrarily
P(:,6) = spatial_pool(data.Xraw(:,:,data.y==1), 'fun', 10);  % choose 10 arbitrarily

figure; 
title('Pooling raw image data (two classes, A and B)');
boxplot(P, 'labels', ...
        {'avg A', 'avg B', 'max A', 'max B', 'fun A', 'fun B'});
ylabel('pool value');
title('whole image pooling, input space');
drawnow;



%% Generate features.
fprintf('[%s]: Running SIFT - please wait a few moments...\n', mfilename);
tic
data.X = cellfun(@(x) run_sift(data.Xraw(:,:,x)), ...
                 num2cell(1:size(data.Xraw,3)), 'UniformOutput', 0);
data.X = cat(4, data.X{:});
toc


% visualize an example or tow
idx = 1;
view_sift_features(data.X(:,:,:,idx),2,2,data.Xraw(:,:,idx));
idx = 2;
view_sift_features(data.X(:,:,:,idx),2,2,data.Xraw(:,:,idx));


%% Run whole-image pooling

fprintf('[%s]: Running whole-image pooling - please wait a few moments...\n', mfilename);

data.Xavg = zeros(size(data.X,3), 2*nExamples);
data.Xmax = zeros(size(data.X,3), 2*nExamples);
data.Xfun = zeros(size(data.X,3), 2*nExamples);

tic
for ii = 1:length(data.y)
    data.Xavg(:,ii) = spatial_pool(data.X(:,:,:,ii), 'avg');
    data.Xmax(:,ii) = spatial_pool(data.X(:,:,:,ii), 'max');
    
    % NOTE: if this were a real application, we would select the MAXFUN
    % hyperparameter using cross-validation.  This would require we
    % have already split data into train/test at this point. However,
    % for the purposes of this particular experiment, it is fine to
    % just pick some value a-priori (there is no real meaningful
    % classification comparison that will result from this particular
    % study).
    data.Xfun(:,ii) = spatial_pool(data.X(:,:,:,ii), 'fun', 10);
end
toc


%% Classification "results"

% As mentioned above, these results are not very interesting because
% this problem is trivial once we generate SIFT features.
%
% Note: all the transposing below is because the SVM codes want
% objects-as-rows.
%

fprintf('[%s]: Training/evaluating classifiers; please wait a few moments...\n', mfilename);


Acc = zeros(nFolds, 3);

tic
for ii = 1:nFolds
    isTrain = (data.foldId == ii);
   
    % evaluate average pooling
    yHat = eval_svm(data.Xavg(:,isTrain)', data.y(isTrain), ...
                    data.Xavg(:,~isTrain)', data.y(~isTrain));
    Acc(ii,1) = sum(yHat == data.y(~isTrain)) / sum(~isTrain);
   
    % evaluate max pooling
    yHat = eval_svm(data.Xmax(:,isTrain)', data.y(isTrain), ...
                    data.Xmax(:,~isTrain)', data.y(~isTrain));
    Acc(ii,2) = sum(yHat == data.y(~isTrain)) / sum(~isTrain);

    % evalute MAXFUN pooling
    yHat = eval_svm(data.Xfun(:,isTrain)', data.y(isTrain), ...
                    data.Xfun(:,~isTrain)', data.y(~isTrain));
    Acc(ii,3) = sum(yHat == data.y(~isTrain)) / sum(~isTrain);
end
toc

fprintf('[%s]: accuracies over %d folds (rows) for average, max and maxfun pooling (columns)\n', ...
        mfilename, nFolds);
Acc


% Just for grins, take a look at a low-dimensional representation of
% the featurized and pooled data.

D = pdist(data.Xavg', 'euclidean');
[Y,e] = cmdscale(D);
figure;
plot(Y(data.y==0,1), Y(data.y==0,2), 'bo', ...
     Y(data.y==1,1), Y(data.y==1,2), 'rx');
legend('class A', 'class B');
xlabel('x1');  ylabel('x2');
title('MDS for avg pooled features');
saveas(gcf, 'mds_avg.eps', 'epsc');


D = pdist(data.Xmax', 'euclidean');
[Y,e] = cmdscale(D);
figure;
plot(Y(data.y==0,1), Y(data.y==0,2), 'bo', ...
     Y(data.y==1,1), Y(data.y==1,2), 'rx');
legend('class A', 'class B');
xlabel('x1');  ylabel('x2');
title('MDS for max pooled features');
saveas(gcf, 'mds_max.eps', 'epsc');


D = pdist(data.Xfun', 'euclidean');
[Y,e] = cmdscale(D);
figure;
plot(Y(data.y==0,1), Y(data.y==0,2), 'bo', ...
     Y(data.y==1,1), Y(data.y==1,2), 'rx');
legend('class A', 'class B');
xlabel('x1');  ylabel('x2');
title('MDS for MAXFUN pooled features');
saveas(gcf, 'mds_fun.eps', 'epsc');
